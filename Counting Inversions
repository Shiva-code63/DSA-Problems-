// Counting Inversions using Merge Sort Algorithm
class Solution {
    int merge(vector<int>&arr, vector<int>&temp, int low, int mid, int high){
        int left = low;
        int right = mid + 1;
        int cnt = 0;
        int index = low;
        while (left<=mid && right<=high){
            if (arr[left] <= arr[right]){
                temp[index++] = arr[left];
                left++;
            }
            else{
                cnt += mid - left +1;
                temp[index++] = arr[right];
                right++;
            }
        }
        while (left<=mid) temp[index++] = arr[left++];
        while (right<=high) temp[index++] = arr[right++];
        for (int i=low; i<=high; i++){
            arr[i] = temp[i];
        }
        return cnt;
    }
    int mergeSort(vector<int>&arr, vector<int>&temp, int low, int high){
        if (low >= high) return 0;
        int mid = (low + high)/2;
        int cnt = 0;
        cnt += mergeSort(arr, temp, low, mid);
        cnt += mergeSort(arr, temp, mid+1, high);
        cnt += merge(arr, temp, low, mid, high);
        return cnt;
    }
  public:
    int inversionCount(vector<int> &arr) {
        vector<int>temp(arr.size());
        return mergeSort(arr, temp, 0, arr.size()-1);
    }
};
